
**Замыкание** – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.  
В некоторых языках это невозможно. Но в **JavaScript** все функции изначально являются замыканиями.  
То есть функции автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]`, и могут получить доступ к внешним переменным.

## Лексическое окружение (Lexical Environment)

В JavaScript у каждой выполняемой функции, блока кода `{...}` и скрипта есть связанный с ними внутренний (скрытый) объект, называемый **лексическим окружением** (`LexicalEnvironment`).

Объект лексического окружения состоит из двух частей:

1. **Environment Record** – объект, в котором, как свойства, хранятся все локальные переменные (а также некоторая другая информация, такая как значение `this`).
2. **Ссылка на внешнее лексическое окружение** – то есть то, которое соответствует коду снаружи (вне текущих фигурных скобок).

> **Переменная** – это просто свойство специального внутреннего объекта: `Environment Record`.  
> «Получить или изменить переменную» означает «получить или изменить свойство этого объекта».


Примеры:

```js
// closure-counter.js
// Пример замыкания (closure)

// Функция createCounter создаёт счётчик.
// Внутри неё есть переменная count, к которой может обращаться возвращаемая функция.
// Эта переменная "запоминается" — именно это и есть замыкание.

const log = console.log;

const createCounter = () => {
  let count = 0; // эта переменная остаётся доступной во внутренней функции
  return () => {
    count += 1;
    return count;
  };
};

const counter = createCounter();

log(counter()); // 1
log(counter()); // 2
log(counter()); // 3

// Каждое обращение к counter увеличивает count, потому что замыкание
// сохраняет доступ к переменной count даже после завершения createCounter.
```

```js
// closure-multiply.js
// Пример замыкания (closure) с параметром

// multiplyBy возвращает новую функцию, которая будет умножать число
// на переданный коэффициент (factor).
// Замыкание сохраняет значение factor внутри возвращённой функции.

function multiplyBy(factor) {
  return (number) => {
    return number * factor;
  };
}

const double = multiplyBy(2); // factor = 2
const triple = multiplyBy(3); // factor = 3

console.log(double(5)); // 10
console.log(triple(5)); // 15

// Даже после завершения multiplyBy, переменная factor остаётся доступной
// в возвращённой функции благодаря замыканию.

```

```js
// lexical-environment.js
// Пример лексического окружения (Lexical Environment)

const greeting = "Hello!";

const sayHello = (name) => {
  debugger; // В этот момент лексическое окружение функции sayHello содержит переменные name и greeting
  console.log(`${greeting}, ${name}`);
};

sayHello("my friends!");

// При вызове sayHello создаётся новое лексическое окружение, где:
// - greeting берётся из внешнего окружения (global scope)
// - name — это параметр текущего вызова

// В дебаггере можно увидеть структуру лексического окружения:
// Local → name
// Closure → greeting

```